//http://www.cplusplus.com/reference/string/string/
#include<iostream>
#include<fstream>
#include<sstream>
#include<ctime>
#include <cmath>
#include<list>
using namespace std;

int maxVert=50;

struct VertexType {
	list<int>Adj; // armazena adjacências
	};

////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Convert string to integer
int GetStr2Int(string strConvert) {
	int intReturn;
	intReturn = atoi(strConvert.c_str());
	return(intReturn);
}

// Convert integer to string
string GetInt2Str(int intConvert) {
	stringstream out;
	out << intConvert;
	return(out.str());
}

// escreve arquivo de saída
void writeFile(int S[],int &costS, double &T,double &Tmin,double &TRed){
	short i;
	string str;
	ofstream myfile; // abre arquivo e aponta para posição onde próximo elemento vai ser escrito
  	myfile.open ("teste.txt",ios::out);
	myfile << "Initial temperature: " << T << "\n";
	myfile << "Final temperature: " << Tmin << "\n";
	myfile << "Factor of temperature reduction: " << TRed << "\n";
	str="Caminho: ";
	for (i=1;i<=costS;i++) str=str + GetInt2Str(S[i]) + " "; // imprime solução
	myfile << str << " - Custo: "<< costS << "\n";
	myfile.close();
}

//lê arquivo de entrada - FAZER: passar adjacências para ponteiros para economizar espaço
void readFile(VertexType Vet[],int S[],int &n,int &v1,int &v2){
	string line;
	short v,u,i,temp;
	ifstream myfile; // abre arquivo e aponta para próximo elemento a ser lido
  	myfile.open ("N(O5).in",ios::in);
	if (myfile.is_open()){
		i=0;
		while (myfile.good()){
			i++;
			getline(myfile,line);
			if (i==1) n=GetStr2Int(line);// número de vértices do grafo, converte string para inteiro
			else if (i==2) v1=GetStr2Int(line);// primeiro vértice do caminho viável, converte string para inteiro
			else if (i==3) v2=GetStr2Int(line);// último vértice do caminho viável, converte string para inteiro
			else if (line.length()>0){ // demais vértices do grafo
				temp=line.find_first_of(":");
				v=GetStr2Int(line.substr(0,temp));
				line=line.substr(temp+1);
				while (line.length()>1){
					temp=line.find_first_of(",");
					u=GetStr2Int(line.substr(0,temp));
					line=line.substr(temp+1);
					Vet[v].Adj.push_back(u);
					Vet[u].Adj.push_back(v);
				}
			}
		}
		myfile.close();
	}
	else cout << "Unable to open file";
}

// verifica se vértice já está no caminho
bool verificaAdj(int S[],int &costS,int &u){
	short i=1;
	bool ok=false;
	while ((i<=costS)&&(!ok)){
		if (S[i]==u) ok=true; //u já está no caminho S
		i++;
	}
	return ok;
}

// escolhe aleatoriamente um vértice adjacente a v para adicionar ao caminho, se last=true pode retornar último vértice
int pickVertex(VertexType Vet[],int &v,int S[],int &costS,int &v2,bool ok){
	int Aux[maxVert],u,j=0;
	list<int>:: iterator it;

	for (it=Vet[v].Adj.begin(); it!=Vet[v].Adj.end(); it++){
		u=*it;
		if (!verificaAdj(S,costS,u)){
			if (ok){ // se pode pegar v2
				j++; Aux[j]=u;
			} else if (u!=v2){ // se ok falso, verifica primeiro se vértice não é v2
				j++; Aux[j]=u;
			} 
		}
	}

	if (j>0){ // v tem alguma adjacência ainda não inserido no caminho
		u=rand() % j + 1; // escolhe aleatoriamente entre 1 e j um dos vértices adjacentes de v
		return Aux[u];
	} else return 0;
}

// constrói solução inicial
void constroiSolIn(VertexType Vet[],int S[],int &costS, int &n, int &v1, int &v2){
	int v,u;
	costS=1;
	S[costS]=v=v1;
	u=pickVertex(Vet,v,S,costS,v2,false); // escolhe uma das adjacências de v ainda não no caminho
	while (u!=0){ // pickVertex retorna 0 se não há mais adjacências que possam ser adicionados ao caminho
		costS++; S[costS]=u; 
		v=u;
		u=pickVertex(Vet,v,S,costS,v2,false);
	}
	u=pickVertex(Vet,S[costS],S,costS,v2,true);
	if (u==v2){
		costS++; S[costS]=u; 
	}
	std::cout << "Solução inicial: ";
	for (v=1;v<=costS;v++) std::cout << S[v] << " ";// imprime solução
	std::cout << " - custo: " << costS << "\n";	
}

// constrói solução inicial
void improveSol(VertexType Vet[],int S[],int &costS, int SAux[],int &costSAux, int &n, int &v2){
	int j,v,u;
	j=costS-1;
	v=rand() % j + 1; // escolhe um ponto no caminho a partir do qual refaz a escolha de vértices
	for (j=1;j<=costS;j++){ // remove vértices da Solução a partir da posição j
		if (j<=v) SAux[j]=S[j]; // a partir de j+1 joga fora o resto do caminho
		else u=S[j];
	}
	costSAux=v; // tamanho do novo caminho é o ponto de quebra do caminho antigo
	v=SAux[costSAux]; // pega último vértice do caminho quebrado
	u=pickVertex(Vet,v,SAux,costSAux,v2,false); // vê se v tem adjacências que podem ser acrescentadas
	while (u!=0){
		costSAux++; SAux[costSAux]=u; 
		v=u;
		u=pickVertex(Vet,v,SAux,costSAux,v2,false);
	}
	u=pickVertex(Vet,SAux[costSAux],SAux,costSAux,v2,true); // vê se v2 é adjacente a último vértice e adiciona
	if (u==v2){
		costSAux++; SAux[costSAux]=u; 
	}
}

// atribui os valores do vetor SAux ao vetor S
void replaceSol(int S[],int SAux[],int &costSAux, int &costS){
	int i;
	for (i=1;i<=costSAux;i++) S[i]=SAux[i];
	costS=costSAux;
}

// roda Simulated Annealing para procurar caminhos viáveis nos grafos reduzidos
void SA(VertexType Vet[],int S[],int &costS, double &T, double &Tmin, double &TRed, int &MaxIt, int &n, int &v1, int &v2){
	int i=0,it,costSAux,delta;
	int SAux[maxVert];
	double r;
	while ((T>Tmin)&&(costS!=n)) {
		it=0;
		while ((it<MaxIt)&&(costS<n)) { // número de iterações
			improveSol(Vet,S,costS,SAux,costSAux,n,v2);
			delta=abs(costS-costSAux);
			r=rand() % 10+1;
			if ((costSAux>costS) || (r/10 < exp(-delta/T)) && (delta!=0)){
				replaceSol(S,SAux,costSAux,costS);
				std::cout << "Temp.: "<< T << " - Solução: ";
				for (i=1;i<=costS;i++) std::cout << S[i] << " ";// imprime nova solução
				std::cout << " - custo: " << costS << "\n";
			}
			it++;
		}
		T=T*TRed;
	}
}

int main () {
	VertexType Vet[maxVert];
	double T,Tmin,TRed;
	int MaxIt,costS,n,v1,v2;
	int S[maxVert];
	srand(time(NULL)); // deve ser chamado uma única vez no programa
	T=1.2; // temperatura inicial
	Tmin=0.1; // temperatura final
	TRed=0.9; // fator de redução da temperatura
	MaxIt=20;
	readFile(Vet,S,n,v1,v2);
	constroiSolIn(Vet,S,costS,n,v1,v2);
	SA(Vet,S,costS,T,Tmin,TRed,MaxIt,n,v1,v2);
	writeFile(S,costS,T,Tmin,TRed);
	return 0;
}
